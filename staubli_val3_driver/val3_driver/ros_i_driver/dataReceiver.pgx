<?xml version="1.0" encoding="utf-8" ?>
<Programs xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.staubli.com/robotics/VAL3/Program/2" >
  <Program name="dataReceiver" access="public" >
    <Code><![CDATA[begin
  //  bValidMsgHeader = false
  //  bHeaderDecoded = false
  //  bValidMsgBody = false
  //  bValidMotion = false

  // state machine at initial state
  // 0: receive header
  // 1: decode header
  // 2: receive body
  // 3: decode body
  // 4: push motion into buffer
  // 5: send ACK
  nDataInState=0

  while (bRecvData)
    // usually for state machines a switch-case statement is a neat implementation
    // HOWEVER, at every iteration of while() this task is sequenced and only called
    // after whatever ms is was defined when created.
    // As a result, receiving one single message, pushing motion and sending ACK
    // would take 6 * task period using switch-case statement.
    // The desirable behaviour is to receive and decode a full message, push motion
    // into buffer and then send ACK to client WITHIN ONE ITERATION of while(),
    // hence the if statement sequence below
    if (nDataInState==0)
      call recvMsgHeader()
    endIf
    if (nDataInState==1)
      call decodeMsgHeader()
    endIf
    if (nDataInState==2)
      call recvMsgBody()
    endIf
    if (nDataInState==3)
      call decodeMsgBody()
    endIf
    if (nDataInState==4)
      call pushMotion()
    endIf
    if (nDataInState==5)
      call encodeAck()
      call sendAck()
    endIf

    // assert state machine is working OK
    if (nDataInState<0 or nDataInState>5)
      popUpMsg("Data reception state machine error")
    endIf

    // sequence task
    delay(0)
  endWhile

  //  while (bRecvData)
  //    // receive message prefix + header
  //    call recvMsgHeader()
  //    
  //    if (bValidMsgHeader)
  //      bValidMsgHeader = false
  //      // decode appropriately
  //      call decodeMsgHeader()
  //    endIf
  //    
  //    if (bHeaderDecoded)
  //      bHeaderDecoded = false
  //      // receive and decode message according to msg_type
  //      switch rosGenericMsg.header.nMsgType
  //        case 11
  //          // assume Failure by default (change within decTrajPt())
  //          rosTrajPtAck.header.nReplyCode = 2
  //          //call recvTrajPt()
  //          if (bValidMsgBody)
  //            bValidMsgBody = false
  //            //call decTrajPt()
  //            // always send ACK, with reply_code = SUCCESS or FAILURE
  //            call sendAck()
  //          endIf
  //        break
  //        case 14
  //          // assume Failure by default (change within decTrajPtFull())
  //          rosTrajPtFAck.header.nReplyCode = 2
  //          //call recvTrajPtFull()
  //          if (bValidMsgBody)
  //            bValidMsgBody = false
  //            //call decTrajPtFull()
  //            // always send ACK, with reply_code = SUCCESS or FAILURE
  //            call sendAck()
  //          endIf
  //        break
  //        default
  //          bValidMsgBody = false
  //          bValidMotion = false
  //        break
  //      endSwitch      
  //    endIf
  //    
  //    if (bValidMotion)
  //      call pushMotion()
  //    endIf
  //    
  //    // sequence task
  //    delay(0)
  //  endWhile
end]]></Code>
  </Program>
</Programs>